|----static
|      |-------style.css
|
|----templates
|      |-------index.html
|      |-------layout.html
|
|-app.py 
|-brasileirao.db (já tenho dados)

================================================================================================
================================================================================================
|-app.py
================================================================================================
================================================================================================
import os
os.environ["NO_PROXY"] = "127.0.0.1,localhost"

from flask import Flask, render_template, request, jsonify
import sqlite3
import pandas as pd
from datetime import datetime
from scipy.stats import norm
import socket

app = Flask(__name__, static_folder="static", template_folder="templates")

DB_FILE = "brasileirao.db"

# -----------------------------
# Lista de times e dados iniciais (mantive igual ao seu Gradio)
# -----------------------------
times_list = [
    "Atlético-MG", "Bahia", "Botafogo", "Ceará", "Corinthians",
    "Cruzeiro", "Flamengo", "Fluminense", "Fortaleza", "Juventude",
    "Grêmio", "Internacional", "Mirassol", "Palmeiras", "RB Bragantino",
    "Santos", "São Paulo", "Sport", "Vasco", "Vitória"
]

dados_iniciais = [
    ["Palmeiras",29,19,5,5,"53:26",62],
    ["Flamengo",29,18,7,4,"56:16",61],
    ["Cruzeiro",30,16,9,5,"42:21",57],
    ["Mirassol",30,15,10,5,"52:31",55],
    ["Bahia",30,14,7,9,"40:34",49],
    ["Botafogo",30,13,8,9,"41:28",47],
    ["Fluminense",29,13,5,11,"36:35",44],
    ["Vasco",30,12,6,12,"49:41",42],
    ["São Paulo",30,11,8,11,"33:33",41],
    ["Corinthians",30,10,9,11,"32:35",39],
    ["Grêmio",30,10,9,11,"33:38",39],
    ["RB Bragantino",30,10,6,14,"34:47",36],
    ["Atlético-MG",29,9,9,11,"27:32",36],
    ["Ceará",29,9,8,12,"27:28",35],
    ["Internacional",30,9,8,13,"35:43",35],
    ["Santos",29,8,8,13,"30:42",32],
    ["Vitória",30,7,10,13,"27:44",31],
    ["Fortaleza",29,7,6,16,"27:44",27],
    ["Juventude",30,7,5,18,"24:56",26],
    ["Sport",29,2,11,16,"22:46",17]
]

# -----------------------------
# DB helpers
# -----------------------------
def get_conn():
    return sqlite3.connect(DB_FILE, timeout=30)

def criar_tabelas_e_base():
    conn = get_conn()
    c = conn.cursor()
    c.execute("""
    CREATE TABLE IF NOT EXISTS tabela_base (
        Time TEXT PRIMARY KEY,
        Jogos INTEGER, V INTEGER, E INTEGER, D INTEGER,
        GM INTEGER, GS INTEGER, Pontos INTEGER
    )
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS tabela (
        Time TEXT PRIMARY KEY,
        Jogos INTEGER, V INTEGER, E INTEGER, D INTEGER,
        GM INTEGER, GS INTEGER, Pontos INTEGER
    )
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS matches (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        Data TEXT,
        Time1 TEXT,
        Time2 TEXT,
        Gols1 INTEGER,
        Gols2 INTEGER
    )
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS jogos_futuros (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        Data TEXT,
        Time1 TEXT,
        Time2 TEXT
    )
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS cartoes (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        Time TEXT,
        Jogador TEXT,
        Amarelo INTEGER,
        Vermelho INTEGER
    )
    """)
    conn.commit()

    # popular tabela_base se vazia
    c.execute("SELECT COUNT(*) FROM tabela_base")
    if c.fetchone()[0] == 0:
        for row in dados_iniciais:
            gm, gs = map(int, row[5].split(":"))
            c.execute("INSERT INTO tabela_base(Time,Jogos,V,E,D,GM,GS,Pontos) VALUES(?,?,?,?,?,?,?,?)",
                      (row[0], row[1], row[2], row[3], row[4], gm, gs, row[6]))
        conn.commit()

    # inicializa tabela atual
    c.execute("SELECT COUNT(*) FROM tabela")
    if c.fetchone()[0] == 0:
        c.execute("DELETE FROM tabela")
        c.execute("INSERT INTO tabela SELECT * FROM tabela_base")
        conn.commit()
    conn.close()

criar_tabelas_e_base()

# -----------------------------
# Reconstruir tabela atual (mesma lógica)
# -----------------------------
def reconstruir_tabela():
    conn = get_conn()
    df_base = pd.read_sql("SELECT * FROM tabela_base", conn, index_col="Time")
    df_base[['Jogos','V','E','D','GM','GS','Pontos']] = df_base[['Jogos','V','E','D','GM','GS','Pontos']].astype(int)
    df = df_base.copy()
    df_matches = pd.read_sql("SELECT * FROM matches ORDER BY id ASC", conn)
    for _, m in df_matches.iterrows():
        t1, t2, g1, g2 = m['Time1'], m['Time2'], int(m['Gols1']), int(m['Gols2'])
        df.at[t1, 'Jogos'] += 1; df.at[t2, 'Jogos'] += 1
        df.at[t1, 'GM'] += g1; df.at[t1, 'GS'] += g2
        df.at[t2, 'GM'] += g2; df.at[t2, 'GS'] += g1
        if g1 > g2:
            df.at[t1, 'V'] += 1; df.at[t2, 'D'] += 1; df.at[t1, 'Pontos'] += 3
        elif g1 < g2:
            df.at[t2, 'V'] += 1; df.at[t1, 'D'] += 1; df.at[t2, 'Pontos'] += 3
        else:
            df.at[t1, 'E'] += 1; df.at[t2, 'E'] += 1; df.at[t1, 'Pontos'] += 1; df.at[t2, 'Pontos'] += 1
    df_to_store = df.reset_index()
    df_to_store.to_sql("tabela", conn, if_exists="replace", index=False)
    conn.close()
    df_display = df_to_store.sort_values(by=['Pontos','V'], ascending=[False, False]).reset_index(drop=True)
    df_display.index += 1
    return df_display

# -----------------------------
# Funções de gerenciamento (mesmas que você tinha)
# -----------------------------
def adicionar_resultado(data_str, time1, time2, gols1, gols2):
    conn = get_conn(); c = conn.cursor()
    try:
        data_use = datetime.strptime(data_str, "%d/%m/%Y").strftime("%d/%m/%Y")
    except:
        data_use = data_str
    c.execute("INSERT INTO matches (Data,Time1,Time2,Gols1,Gols2) VALUES (?,?,?,?,?)",
              (data_use, time1, time2, int(gols1), int(gols2)))
    conn.commit(); conn.close()
    df = reconstruir_tabela()
    matches_df = pd.read_sql("SELECT * FROM matches ORDER BY id DESC", get_conn())
    return df, matches_df

def atualizar_resultado(match_id, data_str, time1, time2, gols1, gols2):
    conn = get_conn(); c = conn.cursor()
    try:
        data_use = datetime.strptime(data_str, "%d/%m/%Y").strftime("%d/%m/%Y")
    except:
        data_use = data_str
    c.execute("UPDATE matches SET Data=?,Time1=?,Time2=?,Gols1=?,Gols2=? WHERE id=?",
              (data_use, time1, time2, int(gols1), int(gols2), int(match_id)))
    conn.commit(); conn.close()
    df = reconstruir_tabela()
    matches_df = pd.read_sql("SELECT * FROM matches ORDER BY id DESC", get_conn())
    return df, matches_df

def excluir_resultado(match_id):
    conn = get_conn(); c = conn.cursor()
    c.execute("DELETE FROM matches WHERE id=?", (int(match_id),))
    conn.commit(); conn.close()
    df = reconstruir_tabela()
    matches_df = pd.read_sql("SELECT * FROM matches ORDER BY id DESC", get_conn())
    return df, matches_df

# -----------------------------
# Jogos futuros / probabilidades
# -----------------------------
def adicionar_jogo_futuro_db(data_str, time1, time2):
    conn = get_conn(); c = conn.cursor()
    try:
        data_use = datetime.strptime(data_str, "%d/%m/%Y").strftime("%d/%m/%Y")
    except:
        data_use = data_str
    c.execute("INSERT INTO jogos_futuros (Data,Time1,Time2) VALUES (?,?,?)", (data_use,time1,time2))
    conn.commit(); conn.close()
    df = pd.read_sql("SELECT * FROM jogos_futuros ORDER BY id DESC", get_conn())
    return df

def analisar_jogos_futuros_db(time):
    conn = get_conn()
    df_fut = pd.read_sql("SELECT * FROM jogos_futuros", conn)
    df_tab = pd.read_sql("SELECT * FROM tabela", conn, index_col="Time")
    conn.close()

    if df_fut.empty:
        return pd.DataFrame(), f"Nenhum jogo futuro encontrado para {time}."

    # Converter datas
    df_fut['Data_dt'] = pd.to_datetime(df_fut['Data'], format='%d/%m/%Y', errors='coerce')
    hoje = datetime.now().date()
    df_fut = df_fut[df_fut['Data_dt'].dt.date >= hoje]

    # Filtrar jogos do time selecionado
    jogos_time = df_fut[(df_fut['Time1'] == time) | (df_fut['Time2'] == time)].copy()
    if jogos_time.empty:
        return pd.DataFrame(), f"Nenhum jogo futuro encontrado para {time}."

    # Calcular “força” com base nos pontos
    max_pontos = df_tab['Pontos'].max()
    forca_time = df_tab.at[time, 'Pontos'] / max_pontos

    # Gerar estimativa de probabilidade
    prob_list = []
    for _, row in jogos_time.iterrows():
        adversario = row['Time2'] if row['Time1'] == time else row['Time1']
        forca_adv = df_tab.at[adversario, 'Pontos'] / max_pontos
        prob = 0.5 + (forca_time - forca_adv) * 0.4
        prob = max(0.05, min(0.95, prob))  # limite 5–95%

        # Define cor de acordo com o valor
        if prob >= 0.6:
            classe = "prob-alta"
        elif prob >= 0.4:
            classe = "prob-media"
        else:
            classe = "prob-baixa"

        # HTML com tooltip explicativo
        prob_html = (
            f"<span class='{classe}' title='Baseado na diferença de pontos atual entre {time} e {adversario}'>"
            f"{prob*100:.1f}%</span>"
        )
        prob_list.append(prob_html)

    jogos_time['Chance de Vitória'] = prob_list
    jogos_time = jogos_time.sort_values(by='Data_dt').reset_index(drop=True)
    jogos_time.drop(columns=['Data_dt'], inplace=True)

    resumo = (
        f"{len(jogos_time)} jogo(s) futuro(s) restantes para {time} — "
        f"{len(jogos_time)*3} ponto(s) ainda possível(is)."
    )

    # Quando usamos to_html, o Pandas escapa tags por padrão. Desligamos isso mais adiante.
    return jogos_time, resumo


def calcular_probabilidades(time):
    conn = get_conn()
    df_tab = pd.read_sql("SELECT * FROM tabela", conn, index_col="Time")
    df_fut = pd.read_sql("SELECT * FROM jogos_futuros", conn)
    conn.close()
    pontos_atual = df_tab.at[time, 'Pontos']
    jogos_restantes = df_fut[(df_fut['Time1']==time) | (df_fut['Time2']==time)].shape[0]
    p_win, p_draw, p_loss = 0.35, 0.30, 0.35
    mu = pontos_atual + jogos_restantes * (3*p_win + 1*p_draw)
    sigma = (jogos_restantes * ((3-1)**2*p_win + (1-1)**2*p_draw + (0-1)**2*p_loss))**0.5
    prob_rebaix = norm.cdf(42, loc=mu, scale=sigma)
    prob_libertadores = 1 - norm.cdf(60, loc=mu, scale=sigma)
    prob_nada = max(0, 1 - prob_rebaix - prob_libertadores)
    return pd.DataFrame({
        "Cenário": ["Rebaixamento", "Libertadores", "Nenhum objetivo"],
        "Probabilidade": [f"{prob_rebaix*100:.1f}%", f"{prob_libertadores*100:.1f}%", f"{prob_nada*100:.1f}%"]
    })

def analisar_jogos_futuros_com_prob(time):
    jogos_df, resumo = analisar_jogos_futuros_db(time)
    prob_df = calcular_probabilidades(time)
    return jogos_df, resumo, prob_df

# -----------------------------
# Cartões
# -----------------------------
def registrar_cartao_db(time, jogador, amarelo, vermelho):
    conn = get_conn(); c = conn.cursor()
    amarelo, vermelho = int(amarelo), int(vermelho)
    c.execute("SELECT id,Amarelo,Vermelho FROM cartoes WHERE Time=? AND Jogador=?", (time,jogador))
    row = c.fetchone()
    if row:
        id_, a, v = row
        a += amarelo; v += vermelho
        c.execute("UPDATE cartoes SET Amarelo=?,Vermelho=? WHERE id=?", (a,v,id_))
    else:
        c.execute("INSERT INTO cartoes (Time,Jogador,Amarelo,Vermelho) VALUES (?,?,?,?)", (time,jogador,amarelo,vermelho))
    conn.commit(); conn.close()
    conn = get_conn()
    df = pd.read_sql("SELECT * FROM cartoes ORDER BY id DESC", conn); conn.close()
    aviso = ""
    conn = get_conn(); c = conn.cursor()
    c.execute("SELECT Amarelo,Vermelho FROM cartoes WHERE Time=? AND Jogador=?", (time,jogador))
    r = c.fetchone(); conn.close()
    if r and (r[0] >= 3 or r[1] >= 1):
        aviso = f"Atenção! Jogador {jogador} do {time} está suspenso ou perto da suspensão."
    return df, aviso

# -----------------------------
# Rotas principais e APIs (retornam snippets HTML para atualizar abas)
# -----------------------------
@app.route('/')
def index():
    # renderiza a página com as tabs e lista de times
    return render_template('index.html', times_list=times_list)

@app.route('/api/classificacao')
def api_classificacao():
    df = reconstruir_tabela().reset_index()
    df.rename(columns={"index": "Pos"}, inplace=True)
    df["Pos"] = df.index + 1  # garante coluna de posição 1–20

    # Gera HTML manualmente com classes de posição
    html = """
    <table class="table table-striped table-sm text-center align-middle">
      <thead class="table-dark">
        <tr>
          <th>Pos</th>
          <th>Time</th>
          <th>Jogos</th>
          <th>V</th>
          <th>E</th>
          <th>D</th>
          <th>GM</th>
          <th>GS</th>
          <th>Pontos</th>
        </tr>
      </thead>
      <tbody>
    """

    for i, row in df.iterrows():
        pos = row["Pos"]
        if pos <= 4:
            cls = "pos-top4"
        elif pos <= 6:
            cls = "pos-liberta"
        elif pos <= 12:
            cls = "pos-sulamericana"
        elif pos >= 17:
            cls = "pos-rebaixado"
        else:
            cls = ""

        html += f"""
        <tr>
          <td class="{cls}">{pos}</td>
          <td>{row['Time']}</td>
          <td>{row['Jogos']}</td>
          <td>{row['V']}</td>
          <td>{row['E']}</td>
          <td>{row['D']}</td>
          <td>{row['GM']}</td>
          <td>{row['GS']}</td>
          <td>{row['Pontos']}</td>
        </tr>
        """

    html += "</tbody></table>"
    return html


@app.route('/api/matches')
def api_matches():
    df = pd.read_sql("SELECT * FROM matches ORDER BY id DESC", get_conn())
    html = df.to_html(classes="table table-striped table-sm", index=False)
    return html

@app.route('/api/jogos_futuros')
def api_jogos_futuros():
    import pandas as pd
    conn = get_conn()
    df = pd.read_sql("SELECT * FROM jogos_futuros", conn)
    conn.close()

    if df.empty:
        return "<p class='text-muted'>Nenhum jogo futuro cadastrado.</p>"

    # converter string para datetime p/ ordenar
    df['Data_dt'] = pd.to_datetime(df['Data'], format='%d/%m/%Y', errors='coerce')
    df = df.sort_values(by='Data_dt', ascending=True)

    html = """
    <table id="tabela_futuros" class="table table-striped table-sm align-middle text-center">
      <thead class="table-dark">
        <tr><th>ID</th><th>Data</th><th>Mandante</th><th>Visitante</th></tr>
      </thead>
      <tbody>
    """
    for i, row in df.iterrows():
        html += f"""
        <tr data-sort="{i}">
          <td>{row['id']}</td>
          <td>{row['Data']}</td>
          <td>{row['Time1']}</td>
          <td>{row['Time2']}</td>
        </tr>
        """
    html += "</tbody></table>"
    html += """
    <div class='text-center mt-2'>
      <button id='btn_toggle_futuros' class='btn btn-sm btn-outline-secondary'>Mostrar todos</button>
    </div>
    """
    return html

@app.route('/api/cartoes')
def api_cartoes():
    df = pd.read_sql("SELECT * FROM cartoes ORDER BY id DESC", get_conn())
    html = df.to_html(classes="table table-striped table-sm", index=False)
    return html

# ---------- ações: adicionar / atualizar / excluir ----------
@app.route('/action/add_result', methods=['POST'])
def action_add_result():
    data = request.form.get('data') or ""
    t1 = request.form.get('time1') or ""
    t2 = request.form.get('time2') or ""
    g1 = request.form.get('g1') or 0
    g2 = request.form.get('g2') or 0
    if t1 == t2:
        return jsonify({"success": False, "msg": "Mandante e visitante iguais."})
    df, matches = adicionar_resultado(data, t1, t2, g1, g2)
    # retornamos HTML atualizado para as duas abas relevantes
    return jsonify({
        "success": True,
        "msg": "Resultado adicionado.",
        "classificacao_html": reconstruir_tabela().to_html(classes="table table-striped table-sm", index=True),
        "matches_html": pd.read_sql("SELECT * FROM matches ORDER BY id DESC", get_conn()).to_html(classes="table table-striped table-sm", index=False)
    })

@app.route('/action/update_result', methods=['POST'])
def action_update_result():
    mid = request.form.get('id')
    data = request.form.get('data') or ""
    t1 = request.form.get('time1') or ""
    t2 = request.form.get('time2') or ""
    g1 = request.form.get('g1') or 0
    g2 = request.form.get('g2') or 0
    if not mid:
        return jsonify({"success": False, "msg": "ID inválido."})
    if t1 == t2:
        return jsonify({"success": False, "msg": "Mandante e visitante iguais."})
    df, matches = atualizar_resultado(int(mid), data, t1, t2, g1, g2)
    return jsonify({
        "success": True,
        "msg": "Resultado atualizado.",
        "classificacao_html": reconstruir_tabela().to_html(classes="table table-striped table-sm", index=True),
        "matches_html": pd.read_sql("SELECT * FROM matches ORDER BY id DESC", get_conn()).to_html(classes="table table-striped table-sm", index=False)
    })

@app.route('/action/delete_result', methods=['POST'])
def action_delete_result():
    mid = request.form.get('id')
    if not mid:
        return jsonify({"success": False, "msg": "ID inválido."})
    df, matches = excluir_resultado(int(mid))
    return jsonify({
        "success": True,
        "msg": "Resultado excluído.",
        "classificacao_html": reconstruir_tabela().to_html(classes="table table-striped table-sm", index=True),
        "matches_html": pd.read_sql("SELECT * FROM matches ORDER BY id DESC", get_conn()).to_html(classes="table table-striped table-sm", index=False)
    })

@app.route('/action/add_futuro', methods=['POST'])
def action_add_futuro():
    data = request.form.get('data') or ""
    t1 = request.form.get('time1') or ""
    t2 = request.form.get('time2') or ""
    df = adicionar_jogo_futuro_db(data, t1, t2)
    return jsonify({
        "success": True,
        "msg": "Jogo futuro adicionado.",
        "futuros_html": pd.read_sql("SELECT * FROM jogos_futuros ORDER BY id DESC", get_conn()).to_html(classes="table table-striped table-sm", index=False)
    })

@app.route('/action/get_fut_analysis', methods=['GET'])
def action_get_fut_analysis():
    time = request.args.get('time')
    if not time:
        return jsonify({"success": False, "msg": "Time não informado."})
    jogos_df, resumo, prob_df = analisar_jogos_futuros_com_prob(time)
    return jsonify({
        "success": True,
        "resumo": resumo,
        "jogos_html": jogos_df.to_html(classes="table table-striped table-sm text-center align-middle", index=False, escape=False),
        "prob_html": prob_df.to_html(classes="table table-striped table-sm", index=False)
    })

@app.route('/action/add_cartao', methods=['POST'])
def action_add_cartao():
    time = request.form.get('time') or ""
    jogador = request.form.get('jogador') or ""
    amarelo = request.form.get('amarelo') or 0
    vermelho = request.form.get('vermelho') or 0
    df, aviso = registrar_cartao_db(time, jogador, amarelo, vermelho)
    return jsonify({
        "success": True,
        "msg": "Cartão registrado.",
        "cartoes_html": df.to_html(classes="table table-striped table-sm", index=False),
        "aviso": aviso
    })

# -----------------------------
# Executar servidor (mostra IP local)
# -----------------------------
if __name__ == '__main__':
    # mostra IP local para acessar via outro dispositivo
    try:
        hostname = socket.gethostname()
        local_ip = socket.gethostbyname(hostname)
    except:
        local_ip = "127.0.0.1"
    print(f"\n✅ Servidor rodando em: http://{local_ip}:5000\n")
    app.run(host='0.0.0.0', port=5000, debug=True)

================================================================================================
================================================================================================
|----templates
|      |-------index.html
================================================================================================
================================================================================================

{% extends "layout.html" %}

{% block content %}
<div>
  <!-- Tabs -->
  <ul class="nav nav-tabs" id="mainTabs" role="tablist">
    <li class="nav-item" role="presentation"><button class="nav-link active" id="tab-class" data-bs-toggle="tab" data-bs-target="#classificacao" type="button" role="tab">Classificação</button></li>
    <li class="nav-item" role="presentation"><button class="nav-link" id="tab-jogos" data-bs-toggle="tab" data-bs-target="#jogos" type="button" role="tab">Registrar / Histórico</button></li>
    <li class="nav-item" role="presentation"><button class="nav-link" id="tab-futuros" data-bs-toggle="tab" data-bs-target="#futuros" type="button" role="tab">Jogos Futuros</button></li>
    <li class="nav-item" role="presentation"><button class="nav-link" id="tab-cartoes" data-bs-toggle="tab" data-bs-target="#cartoes" type="button" role="tab">Cartões</button></li>
  </ul>

  <div class="tab-content mt-3">
    <!-- CLASSIFICAÇÃO -->
    <div class="tab-pane fade show active" id="classificacao" role="tabpanel">
      <div id="classificacao_container">Carregando...</div>
      <small class="text-muted">Tabela atualizada dinamicamente.</small>
    </div>

    <!-- JOGOS -->
    <div class="tab-pane fade" id="jogos" role="tabpanel">
      <h5>Adicionar Resultado</h5>
      <form id="form_add_result" class="row g-2 mb-3">
        <div class="col-md-2"><input name="data" class="form-control" placeholder="Data (DD/MM/AAAA)"></div>
        <div class="col-md-3">
          <select name="time1" class="form-select" required>
            {% for t in times_list %}<option value="{{ t }}">{{ t }}</option>{% endfor %}
          </select>
        </div>
        <div class="col-md-1"><input name="g1" type="number" class="form-control" value="0" required></div>
        <div class="col-md-3">
          <select name="time2" class="form-select" required>
            {% for t in times_list %}<option value="{{ t }}">{{ t }}</option>{% endfor %}
          </select>
        </div>
        <div class="col-md-1"><input name="g2" type="number" class="form-control" value="0" required></div>
        <div class="col-md-2"><button class="btn btn-success" type="submit">Adicionar</button></div>
      </form>

      <h5>Histórico de Jogos</h5>
      <div id="matches_container">Carregando...</div>

      <hr>
      <h6>Editar / Excluir resultado</h6>
      <form id="form_edit_result" class="row g-2">
        <div class="col-md-2"><input name="id" class="form-control" placeholder="ID do resultado" required></div>
        <div class="col-md-2"><input name="data" class="form-control" placeholder="Data (DD/MM/AAAA)"></div>
        <div class="col-md-2">
          <select name="time1" class="form-select">
            {% for t in times_list %}<option value="{{ t }}">{{ t }}</option>{% endfor %}
          </select>
        </div>
        <div class="col-md-1"><input name="g1" type="number" class="form-control"></div>
        <div class="col-md-2">
          <select name="time2" class="form-select">
            {% for t in times_list %}<option value="{{ t }}">{{ t }}</option>{% endfor %}
          </select>
        </div>
        <div class="col-md-1"><input name="g2" type="number" class="form-control"></div>
        <div class="col-md-12 mt-2">
          <button id="btn_update_result" class="btn btn-primary">Atualizar</button>
          <button id="btn_delete_result" class="btn btn-danger">Excluir</button>
        </div>
      </form>
      <div id="jogos_msg" class="mt-2"></div>
    </div>

    <!-- FUTUROS -->
    <div class="tab-pane fade" id="futuros" role="tabpanel">
      <h5>Adicionar Jogo Futuro</h5>
      <form id="form_add_futuro" class="row g-2 mb-3">
        <div class="col-md-2"><input name="data" class="form-control" placeholder="Data (DD/MM/AAAA)" required></div>
        <div class="col-md-4">
          <select name="time1" class="form-select" required>
            {% for t in times_list %}<option value="{{ t }}">{{ t }}</option>{% endfor %}
          </select>
        </div>
        <div class="col-md-4">
          <select name="time2" class="form-select" required>
            {% for t in times_list %}<option value="{{ t }}">{{ t }}</option>{% endfor %}
          </select>
        </div>
        <div class="col-md-2"><button class="btn btn-warning" type="submit">Adicionar</button></div>
      </form>

      <h6>Jogos Futuros</h6>
      <div id="futuros_container">Carregando...</div>

      <hr>
      <h6>Analisar um time</h6>
      <div class="row g-2">
        <div class="col-md-4">
          <select id="fut_time_sel" class="form-select">
            <option value="">-- selecione --</option>
            {% for t in times_list %}<option value="{{ t }}">{{ t }}</option>{% endfor %}
          </select>
        </div>
        <div class="col-md-2"><button id="btn_analise_fut" class="btn btn-info">Analisar</button></div>
      </div>
      <div id="fut_resumo" class="mt-3"></div>
      <div id="fut_jogos" class="mt-2"></div>
      <div id="fut_probs" class="mt-2"></div>
    </div>

    <!-- CARTÕES -->
    <div class="tab-pane fade" id="cartoes" role="tabpanel">
      <h5>Registrar Cartão</h5>
      <form id="form_add_cartao" class="row g-2 mb-3">
        <div class="col-md-3">
          <select name="time" class="form-select" required>
            {% for t in times_list %}<option value="{{ t }}">{{ t }}</option>{% endfor %}
          </select>
        </div>
        <div class="col-md-4"><input name="jogador" class="form-control" placeholder="Nome do Jogador" required></div>
        <div class="col-md-2"><input name="amarelo" type="number" class="form-control" placeholder="Amarelos" value="0" required></div>
        <div class="col-md-2"><input name="vermelho" type="number" class="form-control" placeholder="Vermelhos" value="0" required></div>
        <div class="col-md-1"><button class="btn btn-danger" type="submit">Registrar</button></div>
      </form>

      <div id="cartoes_container">Carregando...</div>
      <div id="cartoes_aviso" class="mt-2"></div>
    </div>
  </div>
</div>

<script>
  // ===== FUNÇÃO PARA MOSTRAR / RECOLHER JOGOS FUTUROS =====
  function configurarToggleFuturos() {
    const tabela = document.querySelector('#tabela_futuros tbody');
    const btn = document.getElementById('btn_toggle_futuros');
    if (!tabela || !btn) return;

    const linhas = tabela.querySelectorAll('tr');
    linhas.forEach((tr, idx) => {
      if (idx >= 5) tr.style.display = 'none';
    });

    let expandido = false;
    btn.addEventListener('click', () => {
      expandido = !expandido;
      linhas.forEach((tr, idx) => {
        tr.style.display = expandido ? '' : (idx >= 5 ? 'none' : '');
      });
      btn.textContent = expandido ? 'Recolher' : 'Mostrar todos';
    });
  }

  // ===== CARREGAR TABELAS INICIAIS =====
  async function load_all() {
    document.getElementById('classificacao_container').innerHTML = await (await fetch('/api/classificacao')).text();
    document.getElementById('matches_container').innerHTML = await (await fetch('/api/matches')).text();
    document.getElementById('futuros_container').innerHTML = await (await fetch('/api/jogos_futuros')).text();
    document.getElementById('cartoes_container').innerHTML = await (await fetch('/api/cartoes')).text();
    configurarToggleFuturos(); // ativa o botão
  }

  // ===== AO CARREGAR A PÁGINA =====
  window.addEventListener('load', () => {
    load_all();

    // === ADD RESULT ===
    document.getElementById('form_add_result').addEventListener('submit', async (e) => {
      e.preventDefault();
      const form = new FormData(e.target);
      const res = await fetch('/action/add_result', { method: 'POST', body: form });
      const j = await res.json();
      if (j.success) {
        document.getElementById('classificacao_container').innerHTML = j.classificacao_html;
        document.getElementById('matches_container').innerHTML = j.matches_html;
        document.getElementById('jogos_msg').innerHTML = '<div class="alert alert-success">Resultado adicionado.</div>';
        e.target.reset();
      } else {
        document.getElementById('jogos_msg').innerHTML = '<div class="alert alert-danger">'+j.msg+'</div>';
      }
    });

    // === UPDATE RESULT ===
    document.getElementById('btn_update_result').addEventListener('click', async (e) => {
      e.preventDefault();
      const form = new FormData(document.getElementById('form_edit_result'));
      const res = await fetch('/action/update_result', { method: 'POST', body: form });
      const j = await res.json();
      document.getElementById('jogos_msg').innerHTML = '<div class="alert alert-' + (j.success ? 'success' : 'danger') + '">' + j.msg + '</div>';
      if (j.success) {
        document.getElementById('classificacao_container').innerHTML = j.classificacao_html;
        document.getElementById('matches_container').innerHTML = j.matches_html;
      }
    });

    // === DELETE RESULT ===
    document.getElementById('btn_delete_result').addEventListener('click', async (e) => {
      e.preventDefault();
      const form = new FormData(document.getElementById('form_edit_result'));
      const res = await fetch('/action/delete_result', { method: 'POST', body: form });
      const j = await res.json();
      document.getElementById('jogos_msg').innerHTML = '<div class="alert alert-' + (j.success ? 'success' : 'danger') + '">' + j.msg + '</div>';
      if (j.success) {
        document.getElementById('classificacao_container').innerHTML = j.classificacao_html;
        document.getElementById('matches_container').innerHTML = j.matches_html;
      }
    });

    // === ADD FUTURO ===
    document.getElementById('form_add_futuro').addEventListener('submit', async (e) => {
      e.preventDefault();
      const form = new FormData(e.target);
      const res = await fetch('/action/add_futuro', { method: 'POST', body: form });
      const j = await res.json();
      if (j.success) {
        document.getElementById('futuros_container').innerHTML = j.futuros_html;
        configurarToggleFuturos(); // reativa o botão
      }
    });

    // === ANALISAR JOGOS FUTUROS ===
    document.getElementById('btn_analise_fut').addEventListener('click', async (e) => {
      e.preventDefault();
      const sel = document.getElementById('fut_time_sel').value;
      if (!sel) return alert('Selecione um time.');
      const res = await fetch('/action/get_fut_analysis?time=' + encodeURIComponent(sel));
      const j = await res.json();
      if (j.success) {
        document.getElementById('fut_resumo').innerHTML = '<div class="alert alert-info">'+j.resumo+'</div>';
        document.getElementById('fut_jogos').innerHTML = j.jogos_html;
        document.getElementById('fut_probs').innerHTML = j.prob_html;
      }
    });

    // === ADD CARTÃO ===
    document.getElementById('form_add_cartao').addEventListener('submit', async (e) => {
      e.preventDefault();
      const form = new FormData(e.target);
      const res = await fetch('/action/add_cartao', { method: 'POST', body: form });
      const j = await res.json();
      if (j.success) {
        document.getElementById('cartoes_container').innerHTML = j.cartoes_html;
        document.getElementById('cartoes_aviso').innerHTML = j.aviso ? '<div class="alert alert-warning">'+j.aviso+'</div>' : '';
        e.target.reset();
      }
    });
  });
</script>
{% endblock %}

================================================================================================
================================================================================================
|----templates
|      |-------layout.html
================================================================================================
================================================================================================

<!doctype html>
<html lang="pt-br">
  <head>
    <meta charset="utf-8">
    <title>Brasileirão Série A 2025</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Bootstrap (via CDN) -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">

    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  </head>
  <body class="p-4">
    <div class="container-fluid px-0">
      <header class="mb-4 text-center">
        <h1 class="display-6 fw-bold">🏆 Brasileirão Série A 2025</h1>
      </header>

      <div id="main-content">
        {% block content %}{% endblock %}
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
  </body>
</html>

================================================================================================
================================================================================================
|----static
|      |-------style.css
================================================================================================
================================================================================================

/* ======= GERAL ======= */
body {
  background: #f8f9fa;
  font-family: "Segoe UI", Roboto, sans-serif;
  color: #212529;
  margin: 0;
  padding: 0;
}

table {
  font-size: 0.9rem;
  width: 100%;
}

/* Centraliza título e conteúdo geral */
h1, h2, h3 {
  text-align: center;
}

.nav-tabs {
  justify-content: center;
  flex-wrap: wrap;
}

/* ======= CLASSIFICAÇÃO ======= */
#classificacao_container {
  text-align: center;
  overflow-x: auto; /* rolagem horizontal no celular */
  padding: 0 5px; /* pequeno respiro nas bordas */
  width: 100%;
  max-width: 100%;
}

#classificacao_container table {
  border-collapse: collapse;
  width: 100%;        /* <<< usa toda a largura da tela */
  min-width: 650px;   /* <<< garante legibilidade mínima */
  margin: 0;          /* <<< remove margens laterais */
}

#classificacao_container th,
#classificacao_container td {
  text-align: center;
  vertical-align: middle;
  white-space: nowrap;
}

/* ======= CORES DAS POSIÇÕES ======= */
.pos-top4 {
  background-color: #006400 !important; /* verde escuro */
  color: white !important;
  font-weight: bold;
}

.pos-liberta {
  background-color: #00a86b !important; /* verde claro */
  color: white !important;
  font-weight: bold;
}

.pos-sulamericana {
  background-color: #003366 !important; /* azul escuro */
  color: white !important;
  font-weight: bold;
}

.pos-rebaixado {
  background-color: #cc0000 !important; /* vermelho */
  color: white !important;
  font-weight: bold;
}

/* ======= RESPONSIVIDADE ======= */
@media (max-width: 768px) {
  body {
    padding: 0;
  }

  h1 {
    font-size: 1.4rem;
  }

  #classificacao_container table {
    font-size: 0.8rem;
    min-width: 500px;
  }

  .nav-tabs .nav-link {
    font-size: 0.85rem;
    padding: 6px 10px;
  }
}

/* força o layout a usar 100% da largura real */
#main-content, #classificacao_container, table {
  max-width: 100vw !important;
  width: 100% !important;
  margin: 0 !important;
  padding: 0 !important;
}

#btn_toggle_futuros {
  min-width: 120px;
}

/* ======= CABEÇALHOS PADRÃO DAS TABELAS ======= */
.table thead {
  background-color: #000 !important;  /* fundo preto */
  color: #fff !important;              /* texto branco */
  font-weight: bold;
  text-transform: uppercase;
}

/* ======= LINHAS ======= */
.table tbody tr:nth-child(even) {
  background-color: #f2f2f2; /* linha par - cinza claro */
}

.table tbody tr:nth-child(odd) {
  background-color: #ffffff; /* linha ímpar - branca */
}

/* ======= TEXTO ======= */
.table td, .table th {
  text-align: center;
  vertical-align: middle;
}

/* ======= AJUSTES DE TAMANHO ======= */
.table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.9rem;
}

/* ======= CABEÇALHO PADRÃO PRETO / LETRAS BRANCAS ======= */
#classificacao_container table thead,
#futuros_container table thead,
#matches_container table thead,
#cartoes_container table thead {
  background-color: #000 !important;
  color: #fff !important;
  font-weight: bold;
  text-transform: uppercase;
}

/* ======= CORPO (ZEBRADO) ======= */
#classificacao_container table tbody tr:nth-child(even),
#futuros_container table tbody tr:nth-child(even),
#matches_container table tbody tr:nth-child(even),
#cartoes_container table tbody tr:nth-child(even) {
  background-color: #f2f2f2 !important;
}

#classificacao_container table tbody tr:nth-child(odd),
#futuros_container table tbody tr:nth-child(odd),
#matches_container table tbody tr:nth-child(odd),
#cartoes_container table tbody tr:nth-child(odd) {
  background-color: #ffffff !important;
}

/* ======= TEXTO CENTRALIZADO ======= */
#classificacao_container table td, #classificacao_container table th,
#futuros_container table td, #futuros_container table th,
#matches_container table td, #matches_container table th,
#cartoes_container table td, #cartoes_container table th {
  text-align: center;
  vertical-align: middle;
}

/* ======= AJUSTE EXTRA PARA TABELAS GERADAS PELO PANDAS ======= */
#matches_container table.dataframe thead th,
#cartoes_container table.dataframe thead th {
  background-color: #000 !important;
  color: #fff !important;
  font-weight: bold;
  text-transform: uppercase;
}

/* ======= CORES PARA CHANCES DE VITÓRIA ======= */
.prob-alta {
  color: #0a7a0a;
  font-weight: bold;
}

.prob-media {
  color: #b58900;
  font-weight: 600;
}

.prob-baixa {
  color: #c1121f;
  font-weight: bold;
}

/* ======= AJUSTE PARA TABELAS DE JOGOS FUTUROS ======= */
#futuros_container table td,
#fut_jogos table td {
  white-space: nowrap;
  font-size: 0.85rem;
  padding: 4px 6px;
}

#futuros_container table th,
#fut_jogos table th {
  white-space: nowrap;
  font-size: 0.85rem;
}

/* ======= AJUSTE PARA TABELAS DE JOGOS FUTUROS ======= */
#futuros_container table td,
#fut_jogos table td {
  white-space: nowrap;
  font-size: 0.85rem;
  padding: 4px 6px;
}

#futuros_container table th,
#fut_jogos table th {
  white-space: nowrap;
  font-size: 0.85rem;
}

/* ======= AJUSTE PARA TABELA DE CARTÕES ======= */
#cartoes_container table td,
#cartoes_container table th {
  white-space: nowrap;        /* impede quebra de linha */
  font-size: 0.85rem;         /* reduz levemente a fonte */
  padding: 4px 6px;           /* diminui o padding */
}

/* aplica truncamento com reticências apenas à coluna de jogador */
#cartoes_container table td:nth-child(3) {
  max-width: 160px;           /* largura limite para nomes */
  overflow: hidden;
  text-overflow: ellipsis;    /* adiciona "..." se passar do limite */
  white-space: nowrap;
}





